"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@blueprintjs/core");
const react_1 = tslib_1.__importStar(require("react"));
const useArrowKeyDown_1 = tslib_1.__importDefault(require("../hooks/useArrowKeyDown"));
const fuzzy_1 = tslib_1.__importDefault(require("fuzzy"));
// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint
const AutocompleteInput = ({ value, setValue, onBlur, onConfirm, showButton, options = [], placeholder = "Enter value", autoFocus, multiline, id, filterOptions: _filterOptions, itemToQuery: _itemToQuery, renderItem, onNewItem: _onNewItem, disabled, maxItemsDisplayed = Infinity, }) => {
    const [isOpen, setIsOpen] = (0, react_1.useState)(false);
    const itemToQuery = (0, react_1.useMemo)(() => _itemToQuery || ((s) => (s ? `${s}` : "")), [_itemToQuery]);
    const [query, setQuery] = (0, react_1.useState)(() => itemToQuery(value));
    const open = (0, react_1.useCallback)(() => setIsOpen(true), [setIsOpen]);
    const close = (0, react_1.useCallback)(() => setIsOpen(false), [setIsOpen]);
    const [isTyping, setIsTyping] = (0, react_1.useState)(false);
    const filterOptions = (0, react_1.useMemo)(() => _filterOptions ||
        ((o, q) => fuzzy_1.default
            .filter(q, o, { extract: itemToQuery })
            .map((f) => f.original)
            .filter((f) => !!f)), [_filterOptions, itemToQuery]);
    const onNewItem = (0, react_1.useMemo)(() => _onNewItem || ((s) => s), [_onNewItem]);
    const items = (0, react_1.useMemo)(() => (query ? filterOptions(options, query) : options).slice(0, maxItemsDisplayed), [query, options, filterOptions, maxItemsDisplayed]);
    const menuRef = (0, react_1.useRef)(null);
    const inputRef = (0, react_1.useRef)(null);
    const onEnter = (0, react_1.useCallback)((value) => {
        if (isOpen && value) {
            setQuery(itemToQuery(value));
            setValue(value);
            setIsTyping(false);
        }
        else if (onConfirm) {
            onConfirm();
        }
        else {
            setIsOpen(true);
        }
    }, [setValue, onConfirm, isOpen]);
    const { activeIndex, onKeyDown } = (0, useArrowKeyDown_1.default)({
        onEnter,
        results: items,
        menuRef,
    });
    (0, react_1.useEffect)(() => {
        if (!items.length || !isTyping)
            close();
        else
            open();
    }, [items, close, open, isTyping]);
    (0, react_1.useEffect)(() => {
        if (query && isOpen)
            setValue(items[activeIndex] || onNewItem(query));
        else if (query)
            setValue(onNewItem(query));
    }, [setValue, activeIndex, items, onNewItem, query]);
    (0, react_1.useEffect)(() => {
        if (inputRef.current &&
            inputRef.current === document.activeElement &&
            value) {
            const index = itemToQuery(value).length;
            inputRef.current.setSelectionRange(index, index);
        }
        const touchEndListener = (e) => {
            if (!e.target ||
                !menuRef.current ||
                menuRef.current.contains(e.target)) {
                return;
            }
            if (!inputRef.current || inputRef.current.contains(e.target)) {
                return;
            }
            close();
        };
        document.body.addEventListener("touchend", touchEndListener);
        return () => document.body.removeEventListener("touchend", touchEndListener);
    }, [inputRef, menuRef, close]);
    const Input = (0, react_1.useMemo)(() => (multiline ? core_1.TextArea : core_1.InputGroup), [multiline]);
    return (react_1.default.createElement(core_1.Popover, { portalClassName: "roamjs-autocomplete-input", targetClassName: "roamjs-autocomplete-input-target", captureDismiss: true, isOpen: isOpen, onOpened: open, minimal: true, autoFocus: false, enforceFocus: false, position: core_1.PopoverPosition.BOTTOM_LEFT, modifiers: {
            flip: { enabled: false },
            preventOverflow: { enabled: false },
        }, content: react_1.default.createElement(core_1.Menu, { className: "max-h-64 overflow-auto max-w-md", ulRef: menuRef }, items.map((t, i) => {
            const onClick = () => {
                var _a;
                setIsTyping(false);
                setValue(t);
                setQuery(itemToQuery(t));
                (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            };
            const sharedProps = {
                onClick,
                onTouchEnd: onClick,
                active: activeIndex === i,
            };
            return renderItem ? (react_1.default.createElement(react_1.default.Fragment, { key: i }, renderItem === null || renderItem === void 0 ? void 0 : renderItem(Object.assign({ item: t }, sharedProps)))) : (react_1.default.createElement(core_1.MenuItem, Object.assign({ text: itemToQuery(t), key: i, multiline: true }, sharedProps)));
        })), target: react_1.default.createElement(Input, Object.assign({ disabled: disabled, value: query, onChange: (e) => {
                setIsTyping(true);
                setQuery(e.target.value);
            }, autoFocus: autoFocus, placeholder: placeholder, onKeyDown: (e) => {
                if (e.key === "Escape") {
                    e.stopPropagation();
                    close();
                }
                else {
                    onKeyDown(e);
                }
            }, id: id, onClick: () => setIsTyping(true), onBlur: (e) => {
                var _a, _b;
                if (e.relatedTarget === null ||
                    !((_b = (_a = e.relatedTarget).closest) === null || _b === void 0 ? void 0 : _b.call(_a, ".roamjs-autocomplete-input"))) {
                    setIsTyping(false);
                }
                if (onBlur) {
                    onBlur(e.target.value);
                }
            }, inputRef: inputRef }, (showButton
            ? {
                rightElement: (react_1.default.createElement(core_1.Button, { icon: "add", minimal: true, onClick: () => onEnter() })),
            }
            : {}))) }));
};
exports.default = AutocompleteInput;
//# sourceMappingURL=AutocompleteInput.js.map