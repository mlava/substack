{"version":3,"file":"compileDatalog.js","sourceRoot":"","sources":["../../src/queries/compileDatalog.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DatalogArgument, DatalogBinding, DatalogClause } from \"../types\";\n\nconst toVar = (v = \"undefined\") => v.replace(/[^\\w-]/g, \"\");\n\nconst compileDatalog = (\n  d:\n    | Partial<DatalogClause>\n    | Partial<DatalogArgument>\n    | Partial<DatalogBinding>,\n  level: number\n): string => {\n  switch (d.type) {\n    case \"data-pattern\":\n      return `[${d.srcVar ? `${compileDatalog(d.srcVar, level)} ` : \"\"}${(\n        d.arguments || []\n      )\n        .map((a) => compileDatalog(a, level))\n        .join(\" \")}]`;\n    case \"src-var\":\n      return `$${toVar(d.value)}`;\n    case \"constant\":\n    case \"underscore\":\n      return d.value || \"_\";\n    case \"variable\":\n      return `?${toVar(d.value)}`;\n    case \"fn-expr\":\n      if (!d.binding) return \"\";\n      return `[(${d.fn} ${(d.arguments || [])\n        .map((a) => compileDatalog(a, level))\n        .join(\" \")}) ${compileDatalog(d.binding, level)}]`;\n    case \"pred-expr\":\n      return `[(${d.pred} ${(d.arguments || [])\n        .map((a) => compileDatalog(a, level))\n        .join(\" \")})]`;\n    case \"rule-expr\":\n      return `[${d.srcVar ? `${compileDatalog(d.srcVar, level)} ` : \"\"}${(\n        d.arguments || []\n      )\n        .map((a) => compileDatalog(a, level))\n        .join(\" \")}]`;\n    case \"not-clause\":\n      return `(${d.srcVar ? `${compileDatalog(d.srcVar, level)} ` : \"\"}not ${(\n        d.clauses || []\n      )\n        .map((a) => compileDatalog(a, level + 1))\n        .join(\" \")})`;\n    case \"or-clause\":\n      return `(${d.srcVar ? `${compileDatalog(d.srcVar, level)} ` : \"\"}or ${(\n        d.clauses || []\n      )\n        .map((a) => compileDatalog(a, level + 1))\n        .join(\"\\n\")})`;\n    case \"and-clause\":\n      return `${\"\".padStart(level * 2, \" \")}(and\\n${(d.clauses || [])\n        .map((c) => compileDatalog(c, level + 1))\n        .join(\"\\n\")}\\n${\"\".padStart(level * 2, \" \")})`;\n    case \"not-join-clause\":\n      return `(${\n        d.srcVar ? `${compileDatalog(d.srcVar, level)} ` : \"\"\n      }not-join [${(d.variables || [])\n        .map((v) => compileDatalog(v, level))\n        .join(\" \")}] ${(d.clauses || [])\n        .map((a) => compileDatalog(a, level + 1))\n        .join(\" \")})`;\n    case \"or-join-clause\":\n      return `(${\n        d.srcVar ? `${compileDatalog(d.srcVar, level)} ` : \"\"\n      }or-join [${(d.variables || [])\n        .map((v) => compileDatalog(v, level))\n        .join(\" \")}]\\n${(d.clauses || [])\n        .map((a) => compileDatalog(a, level + 1))\n        .join(\"\\n\")})`;\n    case \"bind-scalar\":\n      if (!d.variable) return \"\";\n      return compileDatalog(d.variable, level);\n    default:\n      return \"\";\n  }\n};\n\nexport default compileDatalog;\n"]}