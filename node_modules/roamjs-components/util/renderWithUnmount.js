"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const react_dom_1 = tslib_1.__importDefault(require("react-dom"));
const ExtensionApiContext_1 = tslib_1.__importDefault(require("../components/ExtensionApiContext"));
const dispatchToRegistry_1 = tslib_1.__importDefault(require("./dispatchToRegistry"));
const removeFromRegistry_1 = tslib_1.__importDefault(require("./removeFromRegistry"));
const renderWithUnmount = (el, p, args) => {
    const oldChildren = p.children;
    react_dom_1.default.render(react_1.default.createElement(ExtensionApiContext_1.default, args, el), p);
    const unmount = (observer) => {
        observer.disconnect();
        react_dom_1.default.unmountComponentAtNode(p);
        (0, removeFromRegistry_1.default)({
            reactRoots: [p],
            observers: [observer],
        });
        if (oldChildren.length && document.body.contains(p)) {
            Array.from(oldChildren).forEach((c) => p.appendChild(c));
        }
    };
    const unmountObserver = new MutationObserver((ms, observer) => {
        const addedNodes = [];
        const parentRemoved = ms
            .flatMap((m) => {
            addedNodes.push(...Array.from(m.addedNodes));
            return Array.from(m.removedNodes);
        })
            .some((n) => n === p || n.contains(p));
        if (parentRemoved) {
            const isNodeAdded = addedNodes.some((n) => n.contains(p));
            if (!isNodeAdded)
                unmount(observer);
        }
    });
    unmountObserver.observe(document.body, { childList: true, subtree: true });
    (0, dispatchToRegistry_1.default)({
        reactRoots: [p],
        observers: [unmountObserver],
    });
    return () => unmount(unmountObserver);
};
exports.default = renderWithUnmount;
//# sourceMappingURL=renderWithUnmount.js.map