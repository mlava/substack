{"version":3,"file":"mockRoamEnvironment.js","sourceRoot":"","sources":["../../src/testing/mockRoamEnvironment.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DatalogClause,\n  DatalogConstant,\n  DatalogVariable,\n  PullBlock,\n} from \"../types/native\";\nimport { parseEDNString } from \"edn-data\";\nimport nanoid from \"nanoid\";\nimport { JSDOM } from \"jsdom\";\n\ntype Graph = {\n  state: Record<number, PullBlock>;\n  uids: Record<string, number>;\n  titles: Record<string, number>;\n};\n\ntype EDNValue =\n  | { key: string }\n  | { sym: string }\n  | string\n  | EDNValue[]\n  | { list: EDNValue[] }\n  | { map: [EDNValue, EDNValue][] };\n\nconst initMockGraph = (): Graph => ({\n  state: {},\n  uids: {},\n  titles: {},\n});\n\nconst getDbId = () => Math.ceil(Math.random() * 1000000);\n\ntype Aggregate = { type: \"aggregate\" };\ntype DatalogPullOption =\n  | { type: \"as-expr\"; value: string }\n  | { type: \"limit-expr\" }\n  | { type: \"default-expr\" };\ntype DatalogPullAttr =\n  | DatalogConstant\n  | { type: \"wildcard\"; value: \"*\" }\n  | {\n      type: \"map-spec\";\n      entries: {\n        key: string | DatalogPullOption;\n        value: \"...\" | DatalogPullAttr[];\n      }[];\n    }\n  | { type: \"attr-expr\"; name: string; option: DatalogPullOption };\ntype DatalogPullExpr = {\n  type: \"pull\";\n  variable: DatalogVariable;\n  pattern:\n    | { type: \"pattern-name\"; value: string }\n    | { type: \"pattern-data-literal\"; value: DatalogPullAttr[] };\n};\ntype DatalogFindElem = DatalogVariable | DatalogPullExpr | Aggregate;\ntype DatalogFind = { type: \"rel\"; elements: DatalogFindElem[] };\n\ntype NodeAssignment = { id: number };\ntype Assignment = Record<string, NodeAssignment | string | number | RegExp>;\nconst isNode = (v: Assignment[string]): v is NodeAssignment =>\n  typeof v === \"object\" && v !== null && !(v instanceof RegExp);\n\ntype QueryResult = Record<string, unknown> | Record<string, unknown>[];\nconst resolvePattern = (\n  pattern: DatalogPullAttr[],\n  result: QueryResult,\n  graph: Graph\n): unknown =>\n  Array.isArray(result)\n    ? result.map((r) => resolvePattern(pattern, r, graph))\n    : pattern.some((pat) => pat.type === \"wildcard\")\n    ? result\n    : Object.fromEntries(\n        pattern.flatMap((pat): [string, unknown][] => {\n          if (pat.type === \"constant\") {\n            return [[pat.value, result[pat.value as keyof PullBlock]]];\n          } else if (pat.type === \"attr-expr\") {\n            if (pat.option.type === \"as-expr\") {\n              return [[pat.option.value, result[pat.name as keyof PullBlock]]];\n            } else {\n              throw new Error(\n                `Unexpected pull attribute expression type: ${pat.option.type}`\n              );\n            }\n          } else if (pat.type === \"map-spec\") {\n            return pat.entries.map(({ key, value }) => {\n              const k =\n                typeof key === \"string\"\n                  ? key\n                  : key.type === \"as-expr\"\n                  ? key.value\n                  : \"\";\n              const nestedResult = result[k] as QueryResult | undefined;\n              if (!nestedResult) return [k, []];\n              if (value === \"...\") {\n                const nestedResults = (\n                  Array.isArray(nestedResult) ? nestedResult : [nestedResult]\n                )\n                  .map((a) => a[\":db/id\"])\n                  .filter((id): id is number => typeof id === \"number\")\n                  .map((id) => graph.state[id]);\n                return [k, resolvePattern(pattern, nestedResults, graph)];\n              } else {\n                return [k, resolvePattern(value, nestedResult, graph)];\n              }\n            });\n          } else {\n            throw new Error(`Unexpected pull pattern type: ${pat.type}`);\n          }\n        })\n      );\n\nconst fireQuery = ({\n  graph,\n  find,\n  where,\n}: {\n  graph: Graph;\n  find: DatalogFind;\n  // return-map-spec?\n  with?: DatalogVariable[];\n  // inputs?\n  where: DatalogClause[];\n}) => {\n  const getAssignments = (\n    where: DatalogClause[],\n    initialVars = [] as string[]\n  ) => {\n    return where.reduce(\n      (programs, clause, index) => {\n        if (programs.assignments.size === 0 && index > 0) return programs;\n        const reconcile = (matches: Assignment[], vars: string[]) => {\n          vars.forEach((v) => programs.vars.add(v));\n          programs.assignments = new Set(\n            Array.from(\n              new Set(\n                (programs.assignments.size === 0 && index === 0\n                  ? matches\n                  : Array.from(programs.assignments).flatMap((dict) =>\n                      matches.map((dic) => ({\n                        ...dict,\n                        ...dic,\n                      }))\n                    )\n                ).map((a) =>\n                  // remove duplicate assignments\n                  JSON.stringify(\n                    Object.entries(a).sort(([ka], [kb]) => ka.localeCompare(kb))\n                  )\n                )\n              )\n            ).map((s) => Object.fromEntries(JSON.parse(s)))\n          );\n        };\n        if (clause.type === \"data-pattern\") {\n          const [source, relation, target] = clause.arguments;\n          if (source.type !== \"variable\") {\n            throw new Error(\"Expected source type to be variable\");\n          }\n          const sourceVar = source.value;\n          if (relation.type !== \"constant\") {\n            throw new Error(\"Expected relation type to be constant\");\n          }\n          const rel = relation.value;\n          const targetString = target.value.replace(/^\"/, \"\").replace(/\"$/, \"\");\n          const targetVar = target.value;\n          if (programs.vars.has(sourceVar)) {\n            const newAssignments = Array.from(programs.assignments).flatMap(\n              (dict): Assignment[] => {\n                const sourceEntry = dict[sourceVar];\n                if (!isNode(sourceEntry)) {\n                  throw new Error(\n                    \"Expected the source variable to map to a node\"\n                  );\n                  return [];\n                }\n                const sourceId = sourceEntry.id;\n                if (rel === \":block/refs\") {\n                  throw new Error(\"TODO\");\n                  //   if (target.type !== \"variable\") {\n                  //     throw new Error(\n                  //       \"Expected target for :block/refs to be a variable\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetEntry = dict[targetVar];\n                  //   const refs = (\n                  //     isNode(targetEntry)\n                  //       ? [targetEntry.id]\n                  //       : graph.edges.referencesByUid[sourceId] || []\n                  //   ).map((ref) => ({\n                  //     ...dict,\n                  //     [targetVar]: { uid: ref },\n                  //   }));\n                  //   if (refs.length) programs.vars.add(targetVar);\n                  //   return refs;\n                } else if (rel === \":block/page\") {\n                  //   if (target.type !== \"variable\") {\n                  //     throw new Error(\n                  //       \"Expected target for :block/page to be a variable\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetEntry = dict[targetVar];\n                  //   if (graph.edges.pagesByUid[sourceId]) {\n                  //     return [];\n                  //   } else if (isNode(targetEntry)) {\n                  //     return targetEntry.id ===\n                  //       graph.edges.blocksPageByUid[sourceId]\n                  //       ? [dict]\n                  //       : [];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: {\n                  //           uid: graph.edges.blocksPageByUid[sourceId],\n                  //         },\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":node/title\") {\n                  const sourceTitle = graph.state[sourceId]?.[\":node/title\"];\n                  if (target.type === \"constant\") {\n                    if (graph.titles[targetString] === sourceId) {\n                      return [dict];\n                    } else {\n                      return [];\n                    }\n                  } else if (target.type === \"underscore\") {\n                    return [dict];\n                  } else if (!sourceTitle) {\n                    return [];\n                  } else {\n                    programs.vars.add(targetVar);\n                    return [\n                      {\n                        ...dict,\n                        [targetVar]: sourceTitle,\n                      },\n                    ];\n                  }\n                } else if (rel === \":block/children\") {\n                  if (target.type !== \"variable\") {\n                    throw new Error(\n                      \"Expected target for :block/children to be a variable\"\n                    );\n                  }\n                  const targetEntry = dict[targetVar];\n                  const children = (\n                    isNode(targetEntry)\n                      ? [targetEntry.id]\n                      : (graph.state[sourceId]?.[\":block/children\"] || []).map(\n                          (c) => c[\":db/id\"] || 0\n                        )\n                  ).map((id) => ({\n                    ...dict,\n                    [targetVar]: { id },\n                  }));\n                  if (children.length) programs.vars.add(targetVar);\n                  return children;\n                } else if (rel === \":block/parents\") {\n                  if (target.type !== \"variable\") {\n                    throw new Error(\n                      \"Expected target for :block/parents to be a variable\"\n                    );\n                  }\n                  const targetEntry = dict[targetVar];\n                  const ancestors = (\n                    isNode(targetEntry)\n                      ? [targetEntry.id]\n                      : (graph.state[sourceId]?.[\":block/parents\"] || []).map(\n                          (d) => d[\":db/id\"] || 0\n                        )\n                  ).map((id) => ({\n                    ...dict,\n                    [targetVar]: { id },\n                  }));\n                  if (ancestors.length) programs.vars.add(targetVar);\n                  return ancestors;\n                } else if (rel === \":block/string\") {\n                  //   if (target.type === \"constant\") {\n                  //     if (graph.edges.blocksByUid[sourceId] === targetString) {\n                  //       return [dict];\n                  //     } else {\n                  //       return [];\n                  //     }\n                  //   } else if (target.type === \"underscore\") {\n                  //     return [dict];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: graph.edges.blocksByUid[sourceId],\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":block/heading\") {\n                  //   if (target.type === \"constant\") {\n                  //     if (\n                  //       graph.edges.headingsByUid[sourceId] ===\n                  //       Number(targetString)\n                  //     ) {\n                  //       return [dict];\n                  //     } else {\n                  //       return [];\n                  //     }\n                  //   } else if (target.type === \"underscore\") {\n                  //     return [dict];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: graph.edges.headingsByUid[sourceId],\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":create/user\") {\n                  //   if (target.type !== \"variable\") {\n                  //     throw new Error(\n                  //       \"Expected target for :create/user to be a variable\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetEntry = dict[targetVar];\n                  //   const userId = graph.edges.createUserByUid[sourceId];\n                  //   if (isNode(targetEntry)) {\n                  //     return targetEntry.id === userId ? [dict] : [];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: { uid: userId },\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":edit/user\") {\n                  //   if (target.type !== \"variable\") {\n                  //     throw new Error(\n                  //       \"Expected target for :edit/user to be a variable\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetEntry = dict[targetVar];\n                  //   const userId = graph.edges.editUserByUid[sourceId];\n                  //   if (isNode(targetEntry)) {\n                  //     return targetEntry.id === userId ? [dict] : [];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: { uid: userId },\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":create/time\") {\n                  //   if (target.type === \"constant\") {\n                  //     if (\n                  //       graph.edges.createTimeByUid[sourceId] ===\n                  //       Number(targetString)\n                  //     ) {\n                  //       return [dict];\n                  //     } else {\n                  //       return [];\n                  //     }\n                  //   } else if (target.type === \"underscore\") {\n                  //     return [dict];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: graph.edges.createTimeByUid[sourceId],\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":edit/time\") {\n                  //   if (target.type === \"constant\") {\n                  //     if (\n                  //       graph.edges.editTimeByUid[sourceId] ===\n                  //       Number(targetString)\n                  //     ) {\n                  //       return [dict];\n                  //     } else {\n                  //       return [];\n                  //     }\n                  //   } else if (target.type === \"underscore\") {\n                  //     return [dict];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: graph.edges.editTimeByUid[sourceId],\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":user/display-name\") {\n                  //   if (target.type === \"constant\") {\n                  //     if (\n                  //       graph.edges.userDisplayByUid[sourceId] === targetString\n                  //     ) {\n                  //       return [dict];\n                  //     } else {\n                  //       return [];\n                  //     }\n                  //   } else if (target.type === \"underscore\") {\n                  //     return [dict];\n                  //   } else {\n                  //     programs.vars.add(targetVar);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [targetVar]: graph.edges.userDisplayByUid[sourceId],\n                  //       },\n                  //     ];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else {\n                  throw new Error(`Unknown rel: ${rel}`);\n                }\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else if (\n            target.type === \"variable\" &&\n            programs.vars.has(targetVar)\n          ) {\n            const newAssignments = Array.from(programs.assignments).flatMap(\n              (_dict) => {\n                // const targetEntry = dict[targetVar];\n                if (rel === \":block/refs\") {\n                  //   if (!isNode(targetEntry)) {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a node in :block/refs\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetId = targetEntry.id;\n                  //   const refs = (\n                  //     graph.edges.linkedReferencesByUid[targetId] || []\n                  //   ).map((ref) => ({\n                  //     ...dict,\n                  //     [v]: { uid: ref },\n                  //   }));\n                  //   if (refs.length) programs.vars.add(v);\n                  //   return refs;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":block/page\") {\n                  //   if (!isNode(targetEntry)) {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a node in :block/page\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetId = targetEntry.id;\n                  //   if (!graph.edges.pagesByUid[targetId]) {\n                  //     return [];\n                  //   } else {\n                  //     const children = Array.from(\n                  //       graph.edges.descendantsByUid[targetId] || []\n                  //     ).map((d) => ({\n                  //       ...dict,\n                  //       [v]: { uid: d },\n                  //     }));\n                  //     if (children.length) programs.vars.add(v);\n                  //     return children;\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":node/title\") {\n                  //   if (typeof targetEntry !== \"string\") {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a string in :block/refs\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const page = graph.edges.pageUidByTitle[targetEntry];\n                  //   if (page) {\n                  //     programs.vars.add(v);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [v]: { uid: page },\n                  //       },\n                  //     ];\n                  //   }\n                  //   return [];\n                  throw new Error(\"TODO\");\n                } else if (rel === \":block/children\") {\n                  //   if (!isNode(targetEntry)) {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a node in :block/children\"\n                  //     );\n                  //   }\n                  //   const targetId = targetEntry.id;\n                  //   const parent = graph.edges.parentByUid[targetId];\n                  //   if (parent) {\n                  //     programs.vars.add(v);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [v]: { uid: parent },\n                  //       },\n                  //     ];\n                  //   } else {\n                  //     return [];\n                  //   }\n                  throw new Error(\"TODO\");\n                } else if (rel === \":block/parents\") {\n                  //   if (!isNode(targetEntry)) {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a node in :block/parents\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const targetId = targetEntry.id;\n                  //   const ancestors = Array.from(\n                  //     graph.edges.ancestorsByUid[targetId] || []\n                  //   ).map((child) => ({\n                  //     ...dict,\n                  //     [v]: { uid: child },\n                  //   }));\n                  //   if (ancestors.length) programs.vars.add(v);\n                  //   return ancestors;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":block/string\") {\n                  //   if (typeof targetEntry !== \"string\") {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a string in :block/string\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const blocks = Object.entries(graph.edges.blocksByUid)\n                  //     .filter(([_, v]) => v === targetEntry)\n                  //     .map(([child]) => ({\n                  //       ...dict,\n                  //       [v]: { uid: child },\n                  //     }));\n                  //   if (blocks.length) programs.vars.add(v);\n                  //   return blocks;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":block/heading\") {\n                  //   if (typeof targetEntry !== \"number\") {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a number in :block/heading\"\n                  //     );\n                  //     return [];\n                  //   }\n                  //   const blocks = Object.entries(graph.edges.headingsByUid)\n                  //     .filter(([_, v]) => v === targetEntry)\n                  //     .map(([child]) => ({\n                  //       ...dict,\n                  //       [v]: { uid: child },\n                  //     }));\n                  //   if (blocks.length) programs.vars.add(v);\n                  //   return blocks;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":create/user\") {\n                  //   if (!isNode(targetEntry)) {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a node in :create/user\"\n                  //     );\n                  //   }\n                  //   const targetId = targetEntry.id;\n                  //   const children = Object.keys(graph.edges.createUserByUid)\n                  //     .filter(\n                  //       (node) => graph.edges.createUserByUid[node] === targetId\n                  //     )\n                  //     .map((d) => ({\n                  //       ...dict,\n                  //       [v]: { uid: d },\n                  //     }));\n                  //   if (children.length) programs.vars.add(v);\n                  //   return children;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":edit/user\") {\n                  //   if (!isNode(targetEntry)) {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a node in :edit/user\"\n                  //     );\n                  //   }\n                  //   const targetId = targetEntry.id;\n                  //   const children = Object.keys(graph.edges.editUserByUid)\n                  //     .filter(\n                  //       (node) =>\n                  //         graph.edges.editUserByUid[Number(node)] === targetId\n                  //     )\n                  //     .map((d) => ({\n                  //       ...dict,\n                  //       [v]: { uid: d },\n                  //     }));\n                  //   if (children.length) programs.vars.add(v);\n                  //   return children;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":create/time\") {\n                  //   if (typeof targetEntry !== \"number\") {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a number in :create/time\"\n                  //     );\n                  //   }\n                  //   const blocks = Object.entries(graph.edges.createTimeByUid)\n                  //     .filter(([_, v]) => v === targetEntry)\n                  //     .map(([child]) => ({\n                  //       ...dict,\n                  //       [v]: { uid: child },\n                  //     }));\n                  //   if (blocks.length) programs.vars.add(v);\n                  //   return blocks;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":edit/time\") {\n                  //   if (typeof targetEntry !== \"number\") {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a number in :edit/time\"\n                  //     );\n                  //   }\n                  //   const blocks = Object.entries(graph.edges.editTimeByUid)\n                  //     .filter(([_, v]) => v === targetEntry)\n                  //     .map(([child]) => ({\n                  //       ...dict,\n                  //       [v]: { uid: child },\n                  //     }));\n                  //   if (blocks.length) programs.vars.add(v);\n                  //   return blocks;\n                  throw new Error(\"TODO\");\n                } else if (rel === \":user/display-name\") {\n                  //   if (typeof targetEntry !== \"string\") {\n                  //     throw new Error(\n                  //       \"Expected the target variable to map to a string in :block/refs\"\n                  //     );\n                  //   }\n                  //   const displayName = targetEntry\n                  //     .replace(/^\"/, \"\")\n                  //     .replace(/\"$/, \"\");\n                  //   const user = graph.edges.userUidByDisplay[displayName];\n                  //   if (user) {\n                  //     programs.vars.add(v);\n                  //     return [\n                  //       {\n                  //         ...dict,\n                  //         [v]: { uid: user },\n                  //       },\n                  //     ];\n                  //   }\n                  //   return [];\n                  throw new Error(\"TODO\");\n                } else {\n                  throw new Error(`Unknown rel: ${rel}`);\n                }\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else {\n            const matches: Assignment[] | Error =\n              rel === \":children/view-type\"\n                ? target.type === \"constant\"\n                  ? Object.values(graph.uids)\n                      .filter(\n                        (id) =>\n                          graph.state[id][\":children/view-type\"] !==\n                          targetString\n                      )\n                      .map((id) => ({ [sourceVar]: { id } }))\n                  : target.type === \"underscore\"\n                  ? Object.values(graph.uids).map((id) => ({\n                      [sourceVar]: { id },\n                    }))\n                  : Object.values(graph.uids).map((id) => ({\n                      [sourceVar]: { id },\n                      [targetVar]:\n                        graph.state[id][\":children/view-type\"] || \":bullet\",\n                    }))\n                : rel === \":block/uid\"\n                ? target.type === \"constant\"\n                  ? [{ [sourceVar]: { id: graph.uids[target.value] } }]\n                  : target.type === \"underscore\"\n                  ? Object.values(graph.uids).map((id) => ({\n                      [sourceVar]: { id },\n                    }))\n                  : Object.entries(graph.uids).map(([uid, id]) => ({\n                      [sourceVar]: { id },\n                      [targetVar]: uid,\n                    }))\n                : new Error(`Unknown rel: ${rel}`);\n            /*\n              rel === \":block/refs\"\n                ? target.type !== \"variable\"\n                  ? []\n                  : Object.entries(graph.edges.referencesByUid).flatMap(\n                      ([source, refs]) =>\n                        refs.map((ref) => ({\n                          [v]: { uid: source },\n                          [targetVar]: { uid: ref },\n                        }))\n                    )\n                : rel === \":block/page\"\n                ? target.type !== \"variable\"\n                  ? []\n                  : Object.entries(graph.edges.blocksPageByUid).map(\n                      ([b, p]) => ({\n                        [v]: { uid: b },\n                        [targetVar]: { uid: p },\n                      })\n                    )\n                : rel === \":node/title\"\n                ? target.type === \"constant\"\n                  ? graph.edges.pageUidByTitle[targetString]\n                    ? [\n                        {\n                          [v]: {\n                            uid: graph.edges.pageUidByTitle[targetString],\n                          },\n                        },\n                      ]\n                    : []\n                  : target.type === \"underscore\"\n                  ? Object.values(graph.edges.pageUidByTitle).map((uid) => ({\n                      [v]: { uid },\n                    }))\n                  : Object.entries(graph.edges.pageUidByTitle).map(\n                      ([title, uid]) => ({\n                        [v]: { uid },\n                        [targetVar]: title,\n                      })\n                    )\n                : rel === \":block/children\"\n                ? target.type !== \"variable\"\n                  ? []\n                  : Object.entries(graph.edges.childrenByUid).flatMap(\n                      ([source, refs]) =>\n                        refs.map((ref) => ({\n                          [v]: { uid: source },\n                          [targetVar]: { uid: ref },\n                        }))\n                    )\n                : rel === \":block/parents\"\n                ? target.type !== \"variable\"\n                  ? []\n                  : Object.entries(graph.edges.ancestorsByUid).flatMap(\n                      ([source, refs]) =>\n                        Array.from(refs).map((ref) => ({\n                          [v]: { uid: source },\n                          [targetVar]: { uid: ref },\n                        }))\n                    )\n                : rel === \":block/string\"\n                ? target.type === \"constant\"\n                  ? Object.entries(graph.edges.blocksByUid)\n                      .filter(([_, text]) => text !== targetString)\n                      .map(([uid]) => ({ [v]: { uid } }))\n                  : target.type === \"underscore\"\n                  ? Object.keys(graph.edges.blocksByUid).map((uid) => ({\n                      [v]: { uid },\n                    }))\n                  : Object.entries(graph.edges.blocksByUid).map(\n                      ([uid, text]) => ({\n                        [v]: { uid },\n                        [targetVar]: text,\n                      })\n                    )\n                : rel === \":block/heading\"\n                ? target.type === \"constant\"\n                  ? Object.entries(graph.edges.headingsByUid)\n                      .filter(([_, text]) => text !== Number(targetString))\n                      .map(([uid]) => ({ [v]: { uid } }))\n                  : target.type === \"underscore\"\n                  ? Object.keys(graph.edges.headingsByUid).map((uid) => ({\n                      [v]: { uid },\n                    }))\n                  : Object.entries(graph.edges.headingsByUid).map(\n                      ([uid, text]) => ({\n                        [v]: { uid },\n                        [targetVar]: text,\n                      })\n                    )\n                : rel === \":create/user\"\n                ? target.type !== \"variable\"\n                  ? []\n                  : Object.entries(graph.edges.createUserByUid).map(\n                      ([b, p]) => ({\n                        [v]: { uid: b },\n                        [targetVar]: { uid: p },\n                      })\n                    )\n                : rel === \":edit/user\"\n                ? target.type !== \"variable\"\n                  ? []\n                  : Object.entries(graph.edges.editUserByUid).map(([b, p]) => ({\n                      [v]: { uid: b },\n                      [targetVar]: { uid: p },\n                    }))\n                : rel === \":create/time\"\n                ? target.type === \"constant\"\n                  ? Object.entries(graph.edges.createTimeByUid)\n                      .filter(([_, text]) => text !== Number(targetString))\n                      .map(([uid]) => ({ [v]: { uid } }))\n                  : target.type === \"underscore\"\n                  ? Object.keys(graph.edges.createTimeByUid).map((uid) => ({\n                      [v]: { uid },\n                    }))\n                  : Object.entries(graph.edges.createTimeByUid).map(\n                      ([uid, text]) => ({\n                        [v]: { uid },\n                        [targetVar]: text,\n                      })\n                    )\n                : rel === \":edit/time\"\n                ? target.type === \"constant\"\n                  ? Object.entries(graph.edges.editTimeByUid)\n                      .filter(([_, text]) => text !== Number(targetString))\n                      .map(([uid]) => ({ [v]: { uid } }))\n                  : target.type === \"underscore\"\n                  ? Object.keys(graph.edges.editTimeByUid).map((uid) => ({\n                      [v]: { uid },\n                    }))\n                  : Object.entries(graph.edges.editTimeByUid).map(\n                      ([uid, text]) => ({\n                        [v]: { uid },\n                        [targetVar]: text,\n                      })\n                    )\n                : rel === \":user/display-name\"\n                ? target.type === \"constant\"\n                  ? graph.edges.userUidByDisplay[targetString]\n                    ? [\n                        {\n                          [v]: {\n                            uid: graph.edges.userUidByDisplay[targetString],\n                          },\n                        },\n                      ]\n                    : []\n                  : target.type === \"underscore\"\n                  ? Object.values(graph.edges.userUidByDisplay).map((uid) => ({\n                      [v]: { uid },\n                    }))\n                  : Object.entries(graph.edges.userUidByDisplay).map(\n                      ([title, uid]) => ({\n                        [v]: { uid },\n                        [targetVar]: title,\n                      })\n                    )*/\n            if (matches instanceof Error) {\n              throw matches;\n            }\n            reconcile(\n              matches,\n              target.type === \"variable\" ? [sourceVar, targetVar] : [sourceVar]\n            );\n          }\n        } else if (\n          clause.type === \"or-clause\" ||\n          clause.type === \"or-join-clause\"\n        ) {\n          let matches: Assignment[] = [];\n          for (const cls of clause.clauses) {\n            const assignments = getAssignments(\n              [cls],\n              Array.from(programs.vars)\n            );\n            if (assignments.size) {\n              matches = Array.from(assignments);\n              break;\n            }\n          }\n          const vars =\n            clause.type === \"or-join-clause\"\n              ? clause.variables.map((v) => v.value)\n              : Object.keys(matches[0] || {});\n          const varSet = new Set(vars);\n          matches.forEach((a) => {\n            Object.keys(a).forEach((k) => {\n              if (!varSet.has(k)) {\n                delete a[k];\n              }\n            });\n          });\n          reconcile(matches, vars);\n        } else if (clause.type === \"and-clause\") {\n          const matches = Array.from(\n            getAssignments(clause.clauses, Array.from(programs.vars))\n          );\n          reconcile(matches, Object.keys(matches[0] || {}));\n        } else if (clause.type === \"pred-expr\") {\n          if (clause.pred === \"clojure.string/includes?\") {\n            const [variable, constant] = clause.arguments;\n            if (variable?.type !== \"variable\") {\n              throw new Error(\n                \"Expected type to be variable for first clojure.string/includes? argument.\"\n              );\n            }\n            const v = variable.value;\n            if (!programs.vars.has(v)) {\n              throw new Error(\n                \"Expected first clojure.string/includes? argument to be predefined variable.\"\n              );\n            }\n            if (constant?.type !== \"constant\") {\n              throw new Error(\n                \"Expected type to be constant for second clojure.string/includes? argument.\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).flatMap(\n              (dict) => {\n                const sourceEntry = dict[v];\n                if (typeof sourceEntry !== \"string\") {\n                  throw new Error(\"Expected the variable to map to a string\");\n                }\n                if (\n                  sourceEntry.includes(\n                    constant.value.replace(/^\"/, \"\").replace(/\"$/, \"\")\n                  )\n                ) {\n                  return [dict];\n                } else {\n                  return [];\n                }\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else if (clause.pred === \"clojure.string/starts-with?\") {\n            const [variable, constant] = clause.arguments;\n            const v = variable.value;\n            if (variable?.type !== \"variable\") {\n              throw new Error(\n                \"Expected type to be variable for first clojure.string/starts-with? argument.\"\n              );\n            }\n            if (!programs.vars.has(v)) {\n              throw new Error(\n                \"Expected first clojure.string/starts-with? argument to be predefined variable.\"\n              );\n            }\n            if (constant?.type !== \"constant\") {\n              throw new Error(\n                \"Expected type to be constant for second clojure.string/starts-with? argument.\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).flatMap(\n              (dict) => {\n                const sourceEntry = dict[v];\n                if (typeof sourceEntry !== \"string\") {\n                  throw new Error(\"Expected the variable to map to a string\");\n                  return [];\n                }\n                if (\n                  sourceEntry.startsWith(\n                    constant.value.replace(/^\"/, \"\").replace(/\"$/, \"\")\n                  )\n                ) {\n                  return [dict];\n                } else {\n                  return [];\n                }\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else if (clause.pred === \"clojure.string/ends-with?\") {\n            const [variable, constant] = clause.arguments;\n            const v = variable.value;\n            if (variable?.type !== \"variable\") {\n              throw new Error(\n                \"Expected type to be variable for first clojure.string/ends-with? argument.\"\n              );\n            }\n            if (!programs.vars.has(v)) {\n              throw new Error(\n                \"Expected first clojure.string/ends-with? argument to be predefined variable.\"\n              );\n            }\n            if (constant?.type !== \"constant\") {\n              throw new Error(\n                \"Expected type to be constant for second clojure.string/ends-with? argument.\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).flatMap(\n              (dict) => {\n                const sourceEntry = dict[v];\n                if (typeof sourceEntry !== \"string\") {\n                  throw new Error(\"Expected the variable to map to a string\");\n                }\n                if (\n                  sourceEntry.endsWith(\n                    constant.value.replace(/^\"/, \"\").replace(/\"$/, \"\")\n                  )\n                ) {\n                  return [dict];\n                } else {\n                  return [];\n                }\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else if (clause.pred === \"re-find\") {\n            const [regex, variable] = clause.arguments;\n            const v = variable.value;\n            const r = regex.value;\n            if (variable?.type !== \"variable\") {\n              throw new Error(\n                \"Expected type to be variable for first re-find argument.\"\n              );\n            }\n            if (!programs.vars.has(v)) {\n              throw new Error(\n                \"Expected first re-find argument to be predefined variable.\"\n              );\n            }\n            if (regex?.type !== \"variable\") {\n              throw new Error(\n                \"Expected type to be variable for second re-find argument.\"\n              );\n            }\n            if (!programs.vars.has(r)) {\n              throw new Error(\n                \"Expected second re-find argument to be predefined variable.\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).filter(\n              (dict) => {\n                const regexEntry = dict[r];\n                if (!(regexEntry instanceof RegExp)) {\n                  throw new Error(\"Expected the variable to map to a regexp\");\n                }\n                const targetEntry = dict[v];\n                if (typeof targetEntry !== \"string\") {\n                  throw new Error(\"Expected the variable to map to a string\");\n                }\n                return regexEntry.test(targetEntry);\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else if (clause.pred === \">\") {\n            const [left, right] = clause.arguments;\n            const l = left.value;\n            const r = right.value;\n            if (left?.type === \"variable\" && !programs.vars.has(l)) {\n              throw new Error(\n                \"If left argument is a variable, it must be predefined\"\n              );\n            }\n            if (right?.type === \"variable\" && !programs.vars.has(r)) {\n              throw new Error(\n                \"If right argument is a variable, it must be predefined\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).filter(\n              (dict) => {\n                const leftValue =\n                  left.type === \"constant\" ? Number(left.value) : dict[r];\n                if (typeof leftValue !== \"number\") {\n                  throw new Error(\"Left argument must be a number\");\n                }\n                const rightValue =\n                  right.type === \"constant\" ? Number(right.value) : dict[r];\n                if (typeof rightValue !== \"number\") {\n                  throw new Error(\"Right argument must be a number\");\n                }\n                return leftValue > rightValue;\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else if (clause.pred === \"<\") {\n            const [left, right] = clause.arguments;\n            const l = left.value;\n            const r = right.value;\n            if (left?.type === \"variable\" && !programs.vars.has(l)) {\n              throw new Error(\n                \"If left argument is a variable, it must be predefined\"\n              );\n            }\n            if (right?.type === \"variable\" && !programs.vars.has(r)) {\n              throw new Error(\n                \"If right argument is a variable, it must be predefined\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).filter(\n              (dict) => {\n                const leftValue =\n                  left.type === \"constant\" ? Number(left.value) : dict[r];\n                if (typeof leftValue !== \"number\") {\n                  throw new Error(\"Left argument must be a number\");\n                }\n                const rightValue =\n                  right.type === \"constant\" ? Number(right.value) : dict[r];\n                if (typeof rightValue !== \"number\") {\n                  throw new Error(\"Right argument must be a number\");\n                }\n                return leftValue < rightValue;\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else {\n            throw new Error(`Unexpected predicate ${clause.pred}`);\n          }\n        } else if (clause.type === \"fn-expr\") {\n          if (clause.fn === \"re-pattern\") {\n            const [constant] = clause.arguments;\n            if (constant?.type !== \"constant\") {\n              throw new Error(\n                \"Expected type to be constant for first re-pattern argument.\"\n              );\n            }\n            const { binding } = clause;\n            if (binding.type !== \"bind-scalar\") {\n              throw new Error(\n                \"Expected type to be scalar for first re-pattern binding.\"\n              );\n            }\n            const newAssignments = Array.from(programs.assignments).map(\n              (dict) => {\n                return {\n                  ...dict,\n                  [binding.variable.value]: new RegExp(\n                    constant.value.replace(/^\"/, \"\").replace(/\"$/, \"\")\n                  ),\n                };\n              }\n            );\n            programs.assignments = new Set(newAssignments);\n          } else {\n            throw new Error(`Unexpected fn name ${clause.fn}`);\n          }\n        } else {\n          throw new Error(`Unexpected type ${clause.type}`);\n        }\n        return programs;\n      },\n      {\n        assignments: new Set<Assignment>([]),\n        vars: new Set<string>(initialVars),\n      }\n    ).assignments;\n  };\n  const assignments = getAssignments(where);\n  const results = Array.from(assignments).map((res) =>\n    find.elements.map((el) => {\n      if (el.type === \"variable\") {\n        const node = res[el.value];\n        if (isNode(node)) {\n          return node.id;\n        } else if (node instanceof RegExp) {\n          return node.source;\n        } else {\n          return node;\n        }\n      } else if (el.type === \"pull\") {\n        const node = res[el.variable.value];\n        if (typeof node === \"undefined\") {\n          throw new Error(\n            `Failed to find ${el.variable.value} in result: ${JSON.stringify(\n              res\n            )}`\n          );\n        }\n        if (el.pattern.type === \"pattern-data-literal\") {\n          if (isNode(node)) {\n            const result = graph.state[node.id];\n            return resolvePattern(el.pattern.value, result, graph);\n          } else {\n            throw new Error(\n              `Unexpected pull variable: ${el.variable.value} - ${node}`\n            );\n          }\n        } else {\n          throw new Error(\n            `Unexpected pull element pattern type: ${el.pattern.type}`\n          );\n        }\n      }\n      throw new Error(`Unexpected Find element type: ${el.type}`);\n    })\n  );\n  return results;\n};\n\nconst mockQuery = ({ graph, query }: { graph: Graph; query: string }) => {\n  const data = parseEDNString(query) as EDNValue[];\n  const findIndex = data.findIndex(\n    (d) => typeof d === \"object\" && \"key\" in d && d.key === \"find\"\n  );\n  const whereIndex = data.findIndex(\n    (d) => typeof d === \"object\" && \"key\" in d && d.key === \"where\"\n  );\n  const findPattern = data.slice(findIndex + 1, whereIndex);\n  const find: DatalogFind = {\n    type: \"rel\",\n    elements: findPattern.map((p): DatalogFind[\"elements\"][number] => {\n      if (typeof p !== \"object\") {\n        throw new Error(\n          `Unexpected type for datalog find, looking for object: ${JSON.stringify(\n            p\n          )}`\n        );\n      }\n      if (\"sym\" in p) return { type: \"variable\" as const, value: p.sym };\n      if (\"list\" in p) {\n        const [pull, name, attrs] = p.list;\n        if (\n          typeof pull !== \"object\" ||\n          !(\"sym\" in pull) ||\n          pull.sym !== \"pull\"\n        ) {\n          throw new Error(\n            `Expected first edn value to be a pull symbol. Found: ${JSON.stringify(\n              p\n            )}`\n          );\n        }\n        if (typeof name !== \"object\" || !(\"sym\" in name)) {\n          throw new Error(\n            `Expected second edn value to be a pull symbol. Found: ${JSON.stringify(\n              p\n            )}`\n          );\n        }\n        if (!Array.isArray(attrs)) {\n          throw new Error(\n            `Expected third edn value to be an array. Found: ${JSON.stringify(\n              p\n            )}`\n          );\n        }\n        return {\n          type: \"pull\",\n          variable: { type: \"variable\", value: name.sym.replace(/^\\?/, \"\") },\n          pattern: {\n            type: \"pattern-data-literal\",\n            value: attrs.map((attr): DatalogPullAttr => {\n              if (typeof attr === \"object\" && \"key\" in attr) {\n                return {\n                  type: \"constant\",\n                  value: `:${attr.key}`,\n                };\n              }\n              if (Array.isArray(attr)) {\n                const [name, expr, option] = attr;\n                if (typeof name !== \"object\" || !(\"key\" in name)) {\n                  throw new Error(\n                    `Expected attribute expression to start with key. Found: ${JSON.stringify(\n                      attr\n                    )}`\n                  );\n                }\n                if (\n                  typeof expr !== \"object\" ||\n                  !(\"key\" in expr) ||\n                  ![\"as\", \"limit\", \"default\"].includes(expr.key)\n                ) {\n                  throw new Error(\n                    `Expected attribute expression to have second key :as, :limit, or :default. Found: ${JSON.stringify(\n                      attr\n                    )}`\n                  );\n                }\n                if (typeof option !== \"string\") {\n                  throw new Error(\n                    `Expected attribute expression to end with literal. Found: ${JSON.stringify(\n                      attr\n                    )}`\n                  );\n                }\n                const pullOption: DatalogPullOption | undefined =\n                  expr.key === \"as\"\n                    ? { type: \"as-expr\", value: option }\n                    : undefined; // should be impossible\n                if (!pullOption) {\n                  throw new Error(\n                    `Expected attribute expression to be an \\`as\\` key. Found: ${JSON.stringify(\n                      expr\n                    )}`\n                  );\n                }\n                return {\n                  type: \"attr-expr\",\n                  name: `:${name.key}`,\n                  option: pullOption,\n                };\n              }\n              if (typeof attr === \"object\" && \"map\" in attr) {\n                return {\n                  type: \"map-spec\",\n                  entries: attr.map.map((entry) => {\n                    const [key, value] = entry;\n                    if (typeof key !== \"object\" || !(\"key\" in key)) {\n                      throw new Error(\n                        `Unexpected pattern map key. Found: ${JSON.stringify(\n                          entry\n                        )}`\n                      );\n                    }\n                    if (\n                      typeof value !== \"object\" ||\n                      !(\"sym\" in value) ||\n                      value.sym !== \"...\"\n                    ) {\n                      throw new Error(\n                        `Unexpected pattern map value. Found: ${JSON.stringify(\n                          entry\n                        )}`\n                      );\n                    }\n                    return {\n                      key: `:${key.key}`,\n                      value: value.sym,\n                    };\n                  }),\n                };\n              }\n              throw new Error(\n                `Unexpected pattern literal attribute. Found: ${JSON.stringify(\n                  attr\n                )}`\n              );\n            }),\n          },\n        };\n      }\n      throw new Error(\n        `Unexpected object for datalog find: ${JSON.stringify(p)}`\n      );\n    }),\n  };\n  const wherePattern = data.slice(whereIndex + 1);\n  const toDatalog = (e: EDNValue): DatalogClause => {\n    if (Array.isArray(e)) {\n      if (e.length === 3) {\n        return {\n          type: \"data-pattern\",\n          arguments: e.map((a) => {\n            if (typeof a === \"object\") {\n              if (\"key\" in a) {\n                return {\n                  type: \"constant\",\n                  value: `:${a.key}`,\n                };\n              } else if (\"sym\" in a) {\n                return {\n                  type: \"variable\",\n                  value: a.sym.slice(1),\n                };\n              } else {\n                throw new Error(\n                  `Expected data-pattern argument to come from non array EDN: ${JSON.stringify(\n                    a\n                  )}`\n                );\n              }\n            } else {\n              return {\n                type: \"constant\",\n                value: a,\n              };\n            }\n          }),\n        };\n      }\n    }\n    throw new Error(`Unknown value for datalog clause: ${JSON.stringify(e)}`);\n  };\n  const where = wherePattern.map(toDatalog);\n  return fireQuery({ graph, find, where });\n};\n\nconst mockRoamEnvironment = () => {\n  const graph = initMockGraph();\n  const dom = new JSDOM();\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  global.window = dom.window;\n  global.document = dom.window.document;\n  global.window.roamAlphaAPI = {\n    ...global.window.roamAlphaAPI,\n    pull: (_, id) => {\n      const pick = (node: PullBlock) => {\n        // TODO - process exp\n        return node;\n      };\n      if (Array.isArray(id)) {\n        const [attr, val] = id;\n        if (attr === \":block/uid\") {\n          return pick(graph.state[graph.uids[val]]);\n        } else if (attr === \":node/title\") {\n          return pick(graph.state[graph.titles[val]]);\n        } else {\n          throw new Error(`Attr is not supported: ${attr}`);\n        }\n      } else if (typeof id === \"number\") {\n        return pick(graph.state[id]);\n      } else {\n        throw new Error(`Id is not supported: ${id}`);\n      }\n    },\n    q: (query, ..._params) => {\n      return mockQuery({ graph, query });\n    },\n    createBlock: async (action) => {\n      if (!action.block) throw new Error(`block field is required`);\n      if (!action.location) throw new Error(`location field is required`);\n      const parent = graph.uids[action.location[\"parent-uid\"]];\n      if (!parent)\n        throw new Error(\n          `Could not find parent by uid: ${action.location[\"parent-uid\"]}`\n        );\n      const parentBlock = graph.state[parent];\n      const id = getDbId();\n      const block = {\n        \":block/string\": action.block.string,\n        \":block/uid\":\n          action.block.uid || window.roamAlphaAPI.util.generateUID(),\n        \":block/parents\": ([{ \":db/id\": parent }] as PullBlock[]).concat(\n          parentBlock[\":block/parents\"] || []\n        ),\n        \":db/id\": id,\n        \":block/order\": action.location.order,\n      };\n      graph.uids[block[\":block/uid\"]] = id;\n      parentBlock[\":block/children\"] = (\n        parentBlock[\":block/children\"] || []\n      ).concat({ \":db/id\": id });\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      graph.state[id] = block;\n    },\n    updateBlock: async (action) => {\n      if (!action.block) throw new Error(`block field is required`);\n      if (!action.block.uid) throw new Error(`block uid is required`);\n      const block = graph.uids[action.block.uid];\n      if (!block) {\n        throw new Error(`Could not find block by uid: ${action.block.uid}`);\n      }\n      if (typeof action.block.string !== \"undefined\") {\n        graph.state[block][\":block/string\"] = action.block.string;\n      }\n      if (typeof action.block.open !== \"undefined\") {\n        graph.state[block][\":block/open\"] = action.block.open;\n      }\n      if (typeof action.block.heading !== \"undefined\") {\n        graph.state[block][\":block/heading\"] = action.block.heading;\n      }\n      if (typeof action.block[\"text-align\"] !== \"undefined\") {\n        graph.state[block][\":block/text-align\"] = action.block[\"text-align\"];\n      }\n      if (typeof action.block[\"children-view-type\"] !== \"undefined\") {\n        graph.state[block][\n          \":children/view-type\"\n        ] = `:${action.block[\"children-view-type\"]}`;\n      }\n    },\n    createPage: async (action) => {\n      if (!action.page) throw new Error(`page field is required`);\n      if (!action.page.title) throw new Error(`page title field is required`);\n      const id = getDbId();\n      const page = {\n        \":node/title\": action.page.title,\n        \":block/uid\": action.page.uid || window.roamAlphaAPI.util.generateUID(),\n        \":db/id\": id,\n      };\n      graph.titles[action.page.title] = id;\n      graph.uids[page[\":block/uid\"]] = id;\n      graph.state[id] = page;\n    },\n  };\n  global.window.roamAlphaAPI.data = {\n    ...global.window.roamAlphaAPI.data,\n    fast: {\n      q: (query, ..._params) => {\n        return mockQuery({ graph, query });\n      },\n    },\n  };\n  global.window.roamAlphaAPI.util = {\n    ...global.window.roamAlphaAPI.util,\n    generateUID: () => nanoid().slice(0, 9),\n  };\n};\n\nexport default mockRoamEnvironment;\n"]}