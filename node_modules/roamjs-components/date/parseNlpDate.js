"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.addNlpDateParser = void 0;
const tslib_1 = require("tslib");
const addWeeks_1 = tslib_1.__importDefault(require("date-fns/addWeeks"));
const addDays_1 = tslib_1.__importDefault(require("date-fns/addDays"));
const startOfWeek_1 = tslib_1.__importDefault(require("date-fns/startOfWeek"));
const startOfMonth_1 = tslib_1.__importDefault(require("date-fns/startOfMonth"));
const startOfYear_1 = tslib_1.__importDefault(require("date-fns/startOfYear"));
const endOfWeek_1 = tslib_1.__importDefault(require("date-fns/endOfWeek"));
const endOfMonth_1 = tslib_1.__importDefault(require("date-fns/endOfMonth"));
const endOfYear_1 = tslib_1.__importDefault(require("date-fns/endOfYear"));
const chrono_node_1 = require("chrono-node");
const getCurrentUserUid_1 = tslib_1.__importDefault(require("../queries/getCurrentUserUid"));
const startOfWeek = (date) => {
    var _a, _b;
    const weekStartsOn = (_b = (_a = window.roamAlphaAPI.pull("[:user/settings]", [
        ":user/uid",
        (0, getCurrentUserUid_1.default)(),
    ])) === null || _a === void 0 ? void 0 : _a[":user/settings"]) === null || _b === void 0 ? void 0 : _b[":first-day-of-week"];
    return (0, startOfWeek_1.default)(date, weekStartsOn ? { weekStartsOn } : undefined);
};
const endOfWeek = (date) => {
    var _a, _b;
    const weekStartsOn = (_b = (_a = window.roamAlphaAPI.pull("[:user/settings]", [
        ":user/uid",
        (0, getCurrentUserUid_1.default)(),
    ])) === null || _a === void 0 ? void 0 : _a[":user/settings"]) === null || _b === void 0 ? void 0 : _b[":first-day-of-week"];
    return (0, endOfWeek_1.default)(date, weekStartsOn ? { weekStartsOn } : undefined);
};
const ORDINAL_WORD_DICTIONARY = {
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    twentieth: 20,
    "twenty first": 21,
    "twenty-first": 21,
    "twenty second": 22,
    "twenty-second": 22,
    "twenty third": 23,
    "twenty-third": 23,
    "twenty fourth": 24,
    "twenty-fourth": 24,
    "twenty fifth": 25,
    "twenty-fifth": 25,
    "twenty sixth": 26,
    "twenty-sixth": 26,
    "twenty seventh": 27,
    "twenty-seventh": 27,
    "twenty eighth": 28,
    "twenty-eighth": 28,
    "twenty ninth": 29,
    "twenty-ninth": 29,
    thirtieth: 30,
    "thirty first": 31,
    "thirty-first": 31,
};
const ORDINAL_REGEX = new RegExp(`\\b(?:${Object.keys(ORDINAL_WORD_DICTIONARY)
    .sort((a, b) => b.length - a.length)
    .join("|")}|(?:[1-9])?[0-9](?:st|nd|rd|th)?)\\b`, "i");
const customDateNlp = new chrono_node_1.Chrono();
const DAYS_OFFSET = {
    sunday: 0,
    sun: 0,
    monday: 1,
    mon: 1,
    tuesday: 2,
    tues: 2,
    tue: 2,
    wednesday: 3,
    wed: 3,
    thursday: 4,
    thurs: 4,
    thur: 4,
    thu: 4,
    friday: 5,
    fri: 5,
    saturday: 6,
    sat: 6,
};
const UPCOMING_PATTERN = new RegExp("(\\W|^)" +
    "(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?" +
    "(?:on\\s*?)?" +
    "upcoming\\s*" +
    "(" +
    Object.keys(DAYS_OFFSET).join("|") +
    ")" +
    "(?=\\W|$)", "i");
// https://github.com/wanasit/chrono/blob/d8da3c840c50c959a62a0840c9a627f39bc765df/src/parsers/en/ENWeekdayParser.js
customDateNlp.parsers.unshift({
    pattern: () => UPCOMING_PATTERN,
    extract: (context, match) => {
        const index = (match.index || 0) + match[1].length;
        const text = match[0].substr(match[1].length, match[0].length - match[1].length);
        const result = context.createParsingResult(index, text);
        const dayOfWeek = match[2].toLowerCase();
        const offset = DAYS_OFFSET[dayOfWeek];
        if (offset === undefined) {
            return null;
        }
        const startMoment = context.refDate;
        const refOffset = startMoment.getDay();
        result.start.assign("weekday", offset);
        if (offset <= refOffset) {
            startMoment.setDate(offset + 7 + startMoment.getDate() - refOffset);
            result.start.assign("day", startMoment.getDate());
            result.start.assign("month", startMoment.getMonth() + 1);
            result.start.assign("year", startMoment.getFullYear());
        }
        else {
            startMoment.setDate(offset + startMoment.getDate() - refOffset);
            result.start.imply("day", startMoment.getDate());
            result.start.imply("month", startMoment.getMonth() + 1);
            result.start.imply("year", startMoment.getFullYear());
        }
        return result;
    },
});
customDateNlp.parsers.push({
    pattern: () => /\b((start|end) )?of\b/i,
    extract: () => ({}),
}, {
    pattern: () => ORDINAL_REGEX,
    extract: () => ({}),
});
const addNlpDateParser = (p) => customDateNlp.parsers.push(p);
exports.addNlpDateParser = addNlpDateParser;
const assignDay = (p, d) => {
    p.assign("year", d.getFullYear());
    p.assign("month", d.getMonth() + 1);
    p.assign("day", d.getDate());
};
customDateNlp.refiners.unshift({
    refine: (_, results) => {
        var _a;
        if (results.length >= 2) {
            const [modifier, date, ...rest] = results;
            if (/start of/i.test(modifier.text)) {
                const dateObj = date.date();
                if (/week/i.test(date.text)) {
                    const newDateObj = startOfWeek(dateObj);
                    assignDay(date.start, newDateObj);
                }
                if (/month/i.test(date.text)) {
                    const newDateObj = (0, startOfMonth_1.default)(dateObj);
                    assignDay(date.start, newDateObj);
                }
                if (/year/i.test(date.text)) {
                    const newDateObj = (0, startOfYear_1.default)(dateObj);
                    assignDay(date.start, newDateObj);
                }
            }
            else if (/end of/i.test(modifier.text)) {
                const dateObj = date.date();
                if (/week/i.test(date.text)) {
                    const newDateObj = endOfWeek(dateObj);
                    assignDay(date.start, newDateObj);
                }
                if (/month/i.test(date.text)) {
                    const newDateObj = (0, endOfMonth_1.default)(dateObj);
                    assignDay(date.start, newDateObj);
                }
                if (/year/i.test(date.text)) {
                    const newDateObj = (0, endOfYear_1.default)(dateObj);
                    assignDay(date.start, newDateObj);
                }
            }
            else if (rest.length >= 2) {
                const [of, d, ...moreRest] = rest;
                if (ORDINAL_REGEX.test(modifier.text) &&
                    date.start.isOnlyWeekdayComponent() &&
                    /of/i.test(of.text)) {
                    const match = (((_a = ORDINAL_REGEX.exec(modifier.text)) === null || _a === void 0 ? void 0 : _a[0]) || "").toLowerCase();
                    const num = ORDINAL_WORD_DICTIONARY[match] ||
                        Number(match.replace(/(?:st|nd|rd|th)$/i, ""));
                    const dateObj = d.date();
                    if (/month/i.test(d.text)) {
                        const startOfMonthDate = (0, startOfMonth_1.default)(dateObj);
                        const originalMonth = startOfMonthDate.getMonth();
                        const startOfWeekDate = startOfWeek(startOfMonthDate);
                        const dayOfWeekDate = (0, addDays_1.default)(startOfWeekDate, date.start.get("weekday") || 0);
                        const newDateObj = (0, addWeeks_1.default)(dayOfWeekDate, num - (originalMonth === dayOfWeekDate.getMonth() ? 1 : 0));
                        assignDay(d.start, newDateObj);
                    }
                    else if (/year/i.test(d.text)) {
                        const startOfYearDate = (0, startOfYear_1.default)(dateObj);
                        const originalYear = startOfYearDate.getFullYear();
                        const startOfWeekDate = startOfWeek(startOfYearDate);
                        const dayOfWeekDate = (0, addDays_1.default)(startOfWeekDate, date.start.get("weekday") || 0);
                        const newDateObj = (0, addWeeks_1.default)(dayOfWeekDate, num - (originalYear === dayOfWeekDate.getFullYear() ? 1 : 0));
                        assignDay(d.start, newDateObj);
                    }
                    else {
                        return results;
                    }
                    return [d, ...moreRest];
                }
            }
            else {
                return results;
            }
            return [date, ...rest];
        }
        return results;
    },
});
const parseNlpDate = (s, ref) => customDateNlp.parseDate(s, ref) || new Date();
const parse = (t, ref) => customDateNlp.parse(t, ref);
exports.parse = parse;
exports.default = parseNlpDate;
//# sourceMappingURL=parseNlpDate.js.map