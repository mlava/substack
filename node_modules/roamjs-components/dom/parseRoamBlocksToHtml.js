"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncParseRoamBlocksToHtml = void 0;
const marked_1 = require("../marked");
const VIEW_CONTAINER = {
    bullet: "ul",
    document: "div",
    numbered: "ol",
};
const HEADINGS = ["p", "h1", "h2", "h3"];
const syncParseRoamBlocksToHtml = ({ content, viewType, level, context, parseInline, }) => {
    if (content.length === 0) {
        return "";
    }
    const items = content.map((t) => {
        let skipChildren = false;
        const componentsWithChildren = (s, ac) => {
            const parent = context.components(s, ac);
            if (parent) {
                return parent;
            }
            else if (/table/i.test(s)) {
                skipChildren = true;
                const flatten = (n) => n.children.length
                    ? n.children
                        .map((c) => flatten(c))
                        .flatMap((c) => c.map((cc) => [n, ...cc]))
                    : [[n]];
                const rows = flatten(t).map((row) => row.slice(1).map((td) => `<td>${parseInline(td.text, Object.assign(Object.assign({}, context), { components: componentsWithChildren }))}</td`));
                const columns = Math.max(...rows.map((row) => row.length), 0);
                const fill = Array(columns).fill("<td></td>");
                const normalizedRows = rows.map((row) => [...row, ...fill.slice(0, columns - row.length)].join(""));
                return `<table class="roam-table"><tbody>${normalizedRows
                    .map((row) => `<tr>${row}</tr>`)
                    .join("")}</tbody></table>`;
            }
            else if (/roam\/render/i.test(s)) {
                skipChildren = true;
                const acCode = ac || "";
                return `<div class="roam-render">${acCode}</div>`;
            }
            return false;
        };
        const classlist = t.textAlign === "left"
            ? ["text-align-left"]
            : t.textAlign === "center"
                ? ["text-align-center"]
                : t.textAlign === "right"
                    ? ["text-align-right"]
                    : [];
        const textToParse = t.text.replace(/#\.([^\s]*)/g, (_, className) => {
            classlist.push(className);
            return "";
        });
        const inlineMarked = parseInline(textToParse, Object.assign(Object.assign({}, context), { components: componentsWithChildren }));
        const innerHtml = `<${HEADINGS[t.heading]}>${inlineMarked}</${HEADINGS[t.heading]}>\n${skipChildren
            ? ""
            : (0, exports.syncParseRoamBlocksToHtml)({
                content: t.children,
                viewType: t.viewType,
                level: level + 1,
                context,
                parseInline,
            })}`;
        if (level > 0 && viewType === "document") {
            classlist.push("document-bullet");
        }
        const attrs = `id="${t.uid}"${classlist.length ? ` class="${classlist.join(" ")}"` : ""}`;
        const blockHtml = level === 0 && viewType === "document"
            ? `<div ${attrs}>${innerHtml}</div>`
            : `<li ${attrs}>${innerHtml}</li>`;
        return blockHtml;
    });
    const containerTag = level > 0 && viewType === "document" ? "ul" : VIEW_CONTAINER[viewType];
    return `<${containerTag}>${items.join("\n")}</${containerTag}>`;
};
exports.syncParseRoamBlocksToHtml = syncParseRoamBlocksToHtml;
const parseRoamBlocksToHtml = (args) => (0, marked_1.getParseInline)().then((parseInline) => (0, exports.syncParseRoamBlocksToHtml)(Object.assign(Object.assign({}, args), { parseInline })));
exports.default = parseRoamBlocksToHtml;
//# sourceMappingURL=parseRoamBlocksToHtml.js.map