"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const esbuild_1 = tslib_1.__importDefault(require("esbuild"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const zod_1 = require("zod");
const appPath_1 = tslib_1.__importDefault(require("./appPath"));
const dotenv_1 = tslib_1.__importDefault(require("dotenv"));
const toVersion_1 = tslib_1.__importDefault(require("./toVersion"));
const readDir_1 = tslib_1.__importDefault(require("./readDir"));
const nodeCompile_1 = require("./nodeCompile");
const getDotEnvObject_1 = tslib_1.__importDefault(require("./getDotEnvObject"));
const esbuildPlugins_1 = tslib_1.__importDefault(require("./esbuildPlugins"));
// @ts-ignore
const build_1 = require("tailwindcss/lib/cli/build");
dotenv_1.default.config();
const cliArgs = zod_1.z.object({
    out: zod_1.z.string().optional(),
    root: zod_1.z.string().optional(),
    external: zod_1.z.union([zod_1.z.string(), zod_1.z.string().array()]).optional(),
    include: zod_1.z.union([zod_1.z.string(), zod_1.z.string().array()]).optional(),
    css: zod_1.z.string().optional(),
    format: zod_1.z.enum(["iife", "cjs", "esm"]).optional(),
    mirror: zod_1.z.string().optional(),
    analyze: zod_1.z.boolean().optional(),
    max: zod_1.z.string().optional(),
    finish: zod_1.z.string().optional(),
    entry: zod_1.z.union([zod_1.z.string(), zod_1.z.string().array()]).optional(),
    extends: zod_1.z.string().optional(),
});
const zPackageJson = zod_1.z
    .object({
    name: zod_1.z.string().optional().default(""),
})
    .optional()
    .default({});
// https://github.com/evanw/esbuild/issues/337#issuecomment-954633403
const importAsGlobals = (mapping = {}) => {
    const escRe = (s) => s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    const filter = new RegExp(Object.keys(mapping).length
        ? Object.keys(mapping)
            .map((mod) => `^${escRe(mod)}$`)
            .join("|")
        : /$^/);
    return {
        name: "global-imports",
        setup(build) {
            build.onResolve({ filter }, (args) => {
                if (!mapping[args.path]) {
                    throw new Error("Unknown global: " + args.path);
                }
                return {
                    path: args.path,
                    namespace: "external-global",
                };
            });
            build.onLoad({
                filter,
                namespace: "external-global",
            }, async (args) => {
                const global = mapping[args.path];
                if (fs_1.default.existsSync(global)) {
                    return {
                        contents: fs_1.default.readFileSync(global).toString(),
                        loader: "js",
                        resolveDir: path_1.default.dirname(global),
                    };
                }
                return {
                    contents: `module.exports = ${global};`,
                    loader: "js",
                    resolveDir: process.cwd(),
                };
            });
        },
    };
};
const DEFAULT_FILES_INCLUDED = ["package.json", "README.md"];
const compile = ({ builder = async (opts) => {
    await esbuild_1.default.build(opts);
}, opts, }) => {
    const { root = ".", out, external, include, css, format, mirror, analyze, finish: onFinishFile = "", entry = [], } = cliArgs.parse(opts);
    const srcRoot = path_1.default.join(root, "src");
    const apiRoot = path_1.default.join(root, "api");
    const packageJsonPath = path_1.default.join(root, "package.json");
    const packageJson = zPackageJson.parse(fs_1.default.existsSync(packageJsonPath)
        ? JSON.parse(fs_1.default.readFileSync(packageJsonPath).toString())
        : {});
    process.env.PACKAGE_NAME = process.env.PACKAGE_NAME || packageJson.name;
    const rootDir = fs_1.default
        .readdirSync(srcRoot, { withFileTypes: true })
        .filter((f) => f.isFile())
        .map((f) => f.name);
    const rootTs = rootDir.filter((f) => /\.tsx?$/.test(f));
    const rootCss = rootDir.filter((f) => /\.css$/.test(f));
    const entryTs = rootTs.length === 1
        ? rootTs[0]
        : ["index.ts", "main.ts"].find((f) => rootTs.includes(f));
    const entryCss = rootCss.length === 1
        ? rootCss[0]
        : ["index.css", "main.css"].find((f) => rootCss.includes(f));
    const externalModules = (typeof external === "string" ? [external] : external || []).map((e) => e.split("="));
    const outdir = path_1.default.join(root, "dist");
    const envObject = (0, getDotEnvObject_1.default)();
    const apiFunctions = fs_1.default.existsSync(apiRoot)
        ? (0, readDir_1.default)(apiRoot).map((f) => f.replace(/^api\//, "").replace(/\.ts$/, ""))
        : [];
    const backendOutdir = path_1.default.join(root, "out");
    return Promise.all([]
        .concat(entryTs
        ? [
            builder({
                absWorkingDir: process.cwd(),
                entryPoints: [
                    path_1.default.join(srcRoot, entryTs),
                    ...(typeof entry === "string" ? [entry] : entry).map((e) => path_1.default.join(srcRoot, e)),
                    ...(entryCss ? [path_1.default.join(srcRoot, entryCss)] : []),
                ],
                outdir,
                bundle: true,
                sourcemap: process.env.NODE_ENV === "production"
                    ? undefined
                    : process.env.NODE_ENV === "test"
                        ? "linked"
                        : "inline",
                define: {
                    "process.env.BLUEPRINT_NAMESPACE": '"bp4"',
                    "process.env.NODE_ENV": `"${process.env.NODE_ENV}"`,
                    "process.env.VERSION": `"${(0, toVersion_1.default)()}"`,
                    "process.env.ORIGIN": process.env.NODE_ENV === "production"
                        ? '"https://samepage.network"'
                        : '"http://localhost:3000"',
                    ...envObject,
                },
                format,
                entryNames: out,
                external: externalModules.map(([e]) => e).concat(["crypto"]),
                plugins: [
                    importAsGlobals(Object.fromEntries(externalModules
                        .filter((e) => e.length > 1)
                        .map(([e, ...g]) => [e, g.join("=")]))),
                    {
                        name: "tailwind",
                        setup(build) {
                            build.onResolve({ filter: /samepage\.css$/ }, () => {
                                return {
                                    path: "samepage.css",
                                    namespace: "samepage",
                                };
                            });
                            build.onLoad({ filter: /samepage\.css$/, namespace: "samepage" }, async () => {
                                const out = path_1.default.join(os_1.default.tmpdir(), "tailwind.css");
                                await (0, build_1.build)({
                                    _: ["build"],
                                    "--config": path_1.default.resolve(path_1.default.join(__dirname, ".."), "tailwind.config.js"),
                                    "--output": out,
                                });
                                return {
                                    // TODO - rid of blueprint once we cut over fully to our own component library
                                    contents: `@import "normalize.css";\n@import "@blueprintjs/core/lib/css/blueprint.css";\n${fs_1.default
                                        .readFileSync(out)
                                        .toString()}`,
                                    loader: "css",
                                    resolveDir: process.cwd(),
                                };
                            });
                        },
                    },
                    ...(0, esbuildPlugins_1.default)("src"),
                    {
                        name: "onFinish",
                        setup(build) {
                            build.onEnd(async () => {
                                DEFAULT_FILES_INCLUDED.concat(typeof include === "string"
                                    ? [include]
                                    : include || [])
                                    .map((f) => path_1.default.join(root, f))
                                    .filter((f) => fs_1.default.existsSync(f))
                                    .forEach((f) => {
                                    fs_1.default.cpSync(f, path_1.default.join(outdir, path_1.default.basename(f)));
                                });
                                if (css) {
                                    const outCssFilename = path_1.default.join(outdir, `${css.replace(/.css$/, "")}.css`);
                                    const inputCssFiles = fs_1.default
                                        .readdirSync(outdir)
                                        .filter((f) => /.css$/.test(f));
                                    if (inputCssFiles.length === 0) {
                                        console.warn(`No css files in the ${outdir} directory`);
                                    }
                                    else if (inputCssFiles.length === 1) {
                                        fs_1.default.renameSync(path_1.default.join(outdir, inputCssFiles[0]), outCssFilename);
                                    }
                                    else {
                                        const baseOutput = path_1.default.basename(outCssFilename);
                                        if (!inputCssFiles.includes(baseOutput))
                                            fs_1.default.writeFileSync(outCssFilename, "");
                                        inputCssFiles.sort().forEach((f) => {
                                            if (baseOutput !== f) {
                                                const cssFileContent = fs_1.default
                                                    .readFileSync(path_1.default.join(outdir, f))
                                                    .toString();
                                                fs_1.default.rmSync(path_1.default.join(outdir, f));
                                                fs_1.default.appendFileSync(outCssFilename, cssFileContent);
                                                fs_1.default.appendFileSync(outCssFilename, "\n");
                                            }
                                        });
                                        // hoist all imports to the top
                                        const outlines = fs_1.default
                                            .readFileSync(outCssFilename)
                                            .toString()
                                            .split("\n");
                                        const imports = outlines.filter((l) => l.startsWith("@import"));
                                        const rest = outlines.filter((l) => !l.startsWith("@import"));
                                        fs_1.default.writeFileSync(outCssFilename, imports.concat(rest).join("\n"));
                                    }
                                }
                                if (onFinishFile &&
                                    fs_1.default.existsSync(path_1.default.join(root, onFinishFile))) {
                                    const customOnFinish = require(path_1.default.resolve(path_1.default.join(root, onFinishFile)));
                                    if (typeof customOnFinish === "function") {
                                        customOnFinish();
                                    }
                                }
                                if (mirror) {
                                    const mirrorPath = path_1.default.resolve(root, mirror);
                                    if (!fs_1.default.existsSync(mirrorPath))
                                        fs_1.default.mkdirSync(mirrorPath, { recursive: true });
                                    (0, readDir_1.default)(outdir)
                                        .filter((f) => fs_1.default.existsSync((0, appPath_1.default)(f)))
                                        .forEach((f) => {
                                        fs_1.default.cpSync((0, appPath_1.default)(f), path_1.default.join(mirrorPath, path_1.default.relative(outdir, f)));
                                    });
                                }
                            });
                        },
                    },
                ],
                metafile: analyze,
                loader: {
                    ".woff": "file",
                    ".woff2": "file",
                    ".yaml": "text",
                },
            }),
        ]
        : [])
        .concat(apiFunctions.length
        ? [
            builder((0, nodeCompile_1.getOpts)({
                outdir: backendOutdir,
                functions: apiFunctions,
                root: apiRoot,
                define: envObject,
                external: externalModules
                    .filter((e) => e.length === 1)
                    .map((e) => e[0]),
            })),
        ]
        : []));
};
exports.default = compile;
//# sourceMappingURL=compile.js.map