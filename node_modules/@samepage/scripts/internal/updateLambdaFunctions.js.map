{"version":3,"file":"updateLambdaFunctions.js","sourceRoot":"","sources":["../../../package/scripts/internal/updateLambdaFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import path from \"path\";\nimport fs from \"fs\";\nimport { Lambda } from \"@aws-sdk/client-lambda\";\nimport archiver from \"archiver\";\nimport crypto from \"crypto\";\nimport readDir from \"./readDir\";\nimport appPath from \"./appPath\";\n\nconst ignorePaths = [\"mocks\"];\n\nconst updateLambdaFunctions = async ({\n  api = \"samepage-network\",\n  out,\n  root = \".\",\n  prefix = \"\",\n}: {\n  api?: string;\n  out: string; // TODO - make this consistent\n  root?: string;\n  prefix?: string;\n}) => {\n  const backendOutdir = path.join(root, out);\n  const backendFunctions = fs.existsSync(backendOutdir)\n    ? readDir(backendOutdir)\n    : [];\n  if (backendFunctions.length) {\n    const lambda = new Lambda({});\n    const options = {\n      date: new Date(\"01-01-1970\"),\n    };\n    await backendFunctions\n      .filter(\n        (f) =>\n          /\\.js$/.test(f) &&\n          !ignorePaths.some((i) => new RegExp(`^${backendOutdir}/${i}`).test(f))\n      )\n      .map((f) => () => {\n        const zip = archiver(\"zip\", { gzip: true, zlib: { level: 9 } });\n        console.log(`Zipping ${f}...`);\n\n        const functionName = f\n          .replace(/\\.js$/, \"\")\n          .replace(new RegExp(`^${backendOutdir}/`), \"\")\n          .replace(/[\\\\/]/g, \"_\");\n        zip.file(appPath(f), {\n          name: `${prefix}${functionName}.js`,\n          ...options,\n        });\n        const shasum = crypto.createHash(\"sha256\");\n        const data: Uint8Array[] = [];\n        return new Promise<void>((resolve, reject) =>\n          zip\n            .on(\"data\", (d) => {\n              data.push(d);\n              shasum.update(d);\n            })\n            .on(\"end\", () => {\n              console.log(`Zip of ${functionName} complete (${data.length}).`);\n              const sha256 = shasum.digest(\"base64\");\n              const FunctionName = `${api}_${prefix}${functionName}`;\n              lambda\n                .getFunction({\n                  FunctionName,\n                })\n                .catch((e) => {\n                  console.warn(\n                    `Function ${FunctionName} not found due to ${e}.`\n                  );\n                  return false as const;\n                })\n                .then((l) => {\n                  if (!l) {\n                    return `Skipping...`;\n                  } else if (sha256 === l.Configuration?.CodeSha256) {\n                    return `No need to upload ${FunctionName}, shas match.`;\n                  } else {\n                    return lambda\n                      .updateFunctionCode({\n                        FunctionName,\n                        Publish: true,\n                        ZipFile: Buffer.concat(data),\n                      })\n                      .then(\n                        (upd) =>\n                          `Succesfully uploaded ${FunctionName} at ${upd.LastModified}`\n                      );\n                  }\n                })\n                .then(console.log)\n                .then(resolve)\n                .catch((e) => {\n                  console.error(`deploy of ${f} failed:`);\n                  reject(e);\n                });\n            })\n            .finalize()\n        );\n      })\n      .reduce((p, c) => p.then(c), Promise.resolve());\n  } else {\n    console.warn(`No functions found in ${backendOutdir}`);\n  }\n};\n\nexport default updateLambdaFunctions;\n"]}