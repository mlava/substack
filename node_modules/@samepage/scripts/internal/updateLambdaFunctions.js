"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const client_lambda_1 = require("@aws-sdk/client-lambda");
const archiver_1 = tslib_1.__importDefault(require("archiver"));
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const readDir_1 = tslib_1.__importDefault(require("./readDir"));
const appPath_1 = tslib_1.__importDefault(require("./appPath"));
const ignorePaths = ["mocks"];
const updateLambdaFunctions = async ({ api = "samepage-network", out, root = ".", prefix = "", }) => {
    const backendOutdir = path_1.default.join(root, out);
    const backendFunctions = fs_1.default.existsSync(backendOutdir)
        ? (0, readDir_1.default)(backendOutdir)
        : [];
    if (backendFunctions.length) {
        const lambda = new client_lambda_1.Lambda({});
        const options = {
            date: new Date("01-01-1970"),
        };
        await backendFunctions
            .filter((f) => /\.js$/.test(f) &&
            !ignorePaths.some((i) => new RegExp(`^${backendOutdir}/${i}`).test(f)))
            .map((f) => () => {
            const zip = (0, archiver_1.default)("zip", { gzip: true, zlib: { level: 9 } });
            console.log(`Zipping ${f}...`);
            const functionName = f
                .replace(/\.js$/, "")
                .replace(new RegExp(`^${backendOutdir}/`), "")
                .replace(/[\\/]/g, "_");
            zip.file((0, appPath_1.default)(f), {
                name: `${prefix}${functionName}.js`,
                ...options,
            });
            const shasum = crypto_1.default.createHash("sha256");
            const data = [];
            return new Promise((resolve, reject) => zip
                .on("data", (d) => {
                data.push(d);
                shasum.update(d);
            })
                .on("end", () => {
                console.log(`Zip of ${functionName} complete (${data.length}).`);
                const sha256 = shasum.digest("base64");
                const FunctionName = `${api}_${prefix}${functionName}`;
                lambda
                    .getFunction({
                    FunctionName,
                })
                    .catch((e) => {
                    console.warn(`Function ${FunctionName} not found due to ${e}.`);
                    return false;
                })
                    .then((l) => {
                    var _a;
                    if (!l) {
                        return `Skipping...`;
                    }
                    else if (sha256 === ((_a = l.Configuration) === null || _a === void 0 ? void 0 : _a.CodeSha256)) {
                        return `No need to upload ${FunctionName}, shas match.`;
                    }
                    else {
                        return lambda
                            .updateFunctionCode({
                            FunctionName,
                            Publish: true,
                            ZipFile: Buffer.concat(data),
                        })
                            .then((upd) => `Succesfully uploaded ${FunctionName} at ${upd.LastModified}`);
                    }
                })
                    .then(console.log)
                    .then(resolve)
                    .catch((e) => {
                    console.error(`deploy of ${f} failed:`);
                    reject(e);
                });
            })
                .finalize());
        })
            .reduce((p, c) => p.then(c), Promise.resolve());
    }
    else {
        console.warn(`No functions found in ${backendOutdir}`);
    }
};
exports.default = updateLambdaFunctions;
//# sourceMappingURL=updateLambdaFunctions.js.map