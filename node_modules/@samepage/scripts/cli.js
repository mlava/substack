#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const build_1 = tslib_1.__importDefault(require("./build"));
const dev_1 = tslib_1.__importDefault(require("./dev"));
const test_1 = tslib_1.__importDefault(require("./test"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const dotenv_1 = tslib_1.__importDefault(require("dotenv"));
dotenv_1.default.config();
const mergeOpts = (args, rawPath) => {
    const root = typeof args.root === "string" ? args.root : ".";
    const configPath = path_1.default.join(root, rawPath);
    const rawConfigOpts = fs_1.default.existsSync(configPath)
        ? JSON.parse(fs_1.default.readFileSync(configPath).toString()).samepage || {}
        : {};
    rawConfigOpts.root = rawConfigOpts.root || root;
    const configOpts = rawConfigOpts.extends
        ? mergeOpts(rawConfigOpts, rawConfigOpts.extends)
        : rawConfigOpts;
    const mergedOpts = { ...configOpts };
    Object.keys(args).forEach((k) => {
        const mergedOptValue = mergedOpts[k];
        const argValue = args[k];
        if (Array.isArray(mergedOptValue)) {
            mergedOpts[k] = [
                ...mergedOptValue,
                ...(typeof argValue === "string"
                    ? [argValue]
                    : Array.isArray(argValue)
                        ? argValue
                        : [`${argValue}`]),
            ];
        }
        else {
            mergedOpts[k] = argValue;
        }
    });
    return mergedOpts;
};
const run = async (command, args) => {
    const cliOpts = args
        .map((a, i) => [
        a,
        args[i + 1] && !args[i + 1].startsWith("--") ? args[i + 1] : true,
    ])
        .filter(([k]) => k.startsWith("--"))
        .map(([k, v]) => [
        k
            .replace(/^--/, "")
            .split(/-/g)
            .map((s, i) => i === 0
            ? s
            : `${s.substring(0, 1).toUpperCase()}${s.substring(1)}`)
            .join(""),
        v,
    ])
        .reduce((prev, [k, v]) => {
        const prevK = prev[k];
        if (v === true) {
            prev[k] = v;
        }
        else if (prevK) {
            if (typeof prevK === "string") {
                prev[k] = [prevK, v];
            }
            else if (prevK !== true) {
                prev[k] = [...prevK, v];
            }
        }
        else {
            prev[k] = v;
        }
        return prev;
    }, {});
    const opts = mergeOpts(cliOpts, "package.json");
    const interpolate = (s) => s.replace(/\$([A-Z_]+)/g, (orig, k) => process.env[k] || orig);
    Object.entries(opts).forEach(([k, v]) => {
        if (typeof v === "string") {
            opts[k] = interpolate(v);
        }
        else if (Array.isArray(v)) {
            opts[k] = v.map(interpolate);
        }
    });
    switch (command) {
        case "build":
            return (0, build_1.default)(opts);
        case "start":
        case "dev":
            return (0, dev_1.default)(opts);
        case "test":
            return (0, test_1.default)(opts);
        default:
            console.error("Command", command, "is unsupported");
            return 1;
    }
};
run(process.argv[2], process.argv.slice(3))
    .then((code) => code >= 0 && process.exit(code))
    .catch((err) => {
    console.error(err);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map