import { createElement, Fragment } from 'react';
import { Lexer } from 'marked';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var defaults = {
  breaks: false,
  gfm: true,
  baseURL: null,
  openLinksInNewTab: true,
  langPrefix: 'language-',
  renderer: null
};

var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'"
};
/** Used to match HTML entities and HTML characters. */

var reEscapedHtml = /&(?:amp|lt|gt|quot|#(?:0+)?39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
var unescape = function unescape() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, function (entity) {
    return htmlUnescapes[entity] || "'";
  }) : string;
};
var joinBase = function joinBase(path, base) {
  if (!base) {
    return path;
  }

  try {
    return new URL(path, base).href;
  } catch (_unused) {
    return path;
  }
};

var ReactRenderer = /*#__PURE__*/function () {
  function ReactRenderer() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults;

    _classCallCheck(this, ReactRenderer);

    _defineProperty(this, "elementId", 0);

    var renderer = options.renderer;
    this.options = options;

    if (renderer && _typeof(renderer) === 'object') {
      Object.entries(renderer).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            rendererName = _ref2[0],
            renderFunction = _ref2[1];

        var originalRenderFunction = _this[rendererName];

        if (rendererName !== 'h' && originalRenderFunction && typeof renderFunction === 'function') {
          _this[rendererName] = function () {
            _this.elementId += 1;
            return renderFunction.bind(_this).apply(void 0, arguments);
          };
        }
      });
    }
  }

  _createClass(ReactRenderer, [{
    key: "h",
    value: function h(el, children, props) {
      var elProps = {
        key: "marked-react-".concat(this.elementId)
      };
      this.elementId += 1;
      return /*#__PURE__*/createElement(el, _objectSpread2(_objectSpread2({}, props), elProps), children);
    }
  }, {
    key: "heading",
    value: function heading(children, level) {
      return this.h("h".concat(level), children);
    }
  }, {
    key: "paragraph",
    value: function paragraph(children) {
      return this.h('p', children);
    }
  }, {
    key: "link",
    value: function link(href, text) {
      var url = joinBase(href, this.options.baseURL);
      var target = this.options.openLinksInNewTab ? '_blank' : null;
      return this.h('a', text, {
        href: url,
        target: target
      });
    }
  }, {
    key: "image",
    value: function image(href, text, title) {
      var url = joinBase(href, this.options.baseURL);
      return this.h('img', null, {
        src: url,
        alt: text,
        title: title
      });
    }
  }, {
    key: "codespan",
    value: function codespan(code, lang) {
      var className = lang ? "".concat(this.options.langPrefix).concat(lang) : null;
      return this.h('code', code, {
        className: className
      });
    }
  }, {
    key: "code",
    value: function code(_code, lang) {
      return this.h('pre', this.codespan(_code, lang));
    }
  }, {
    key: "blockquote",
    value: function blockquote(children) {
      return this.h('blockquote', children);
    }
  }, {
    key: "list",
    value: function list(children, ordered) {
      return this.h(ordered ? 'ol' : 'ul', children);
    }
  }, {
    key: "listItem",
    value: function listItem(children) {
      return this.h('li', children);
    }
  }, {
    key: "checkbox",
    value: function checkbox(checked) {
      return this.h('input', null, {
        type: 'checkbox',
        disabled: true,
        checked: checked
      });
    }
  }, {
    key: "table",
    value: function table(children) {
      return this.h('table', children);
    }
  }, {
    key: "tableHeader",
    value: function tableHeader(children) {
      return this.h('thead', children);
    }
  }, {
    key: "tableBody",
    value: function tableBody(children) {
      return this.h('tbody', children);
    }
  }, {
    key: "tableRow",
    value: function tableRow(children) {
      return this.h('tr', children);
    }
  }, {
    key: "tableCell",
    value: function tableCell(children, flags) {
      var tag = flags.header ? 'th' : 'td';
      return this.h(tag, children, {
        align: flags.align
      });
    }
  }, {
    key: "strong",
    value: function strong(children) {
      return this.h('strong', children);
    }
  }, {
    key: "em",
    value: function em(children) {
      return this.h('em', children);
    }
  }, {
    key: "del",
    value: function del(children) {
      return this.h('del', children);
    }
  }, {
    key: "text",
    value: function text(_text) {
      return _text;
    }
  }, {
    key: "html",
    value: function html(_html) {
      return _html;
    }
  }, {
    key: "hr",
    value: function hr() {
      return this.h('hr');
    }
  }, {
    key: "br",
    value: function br() {
      return this.h('br');
    }
  }]);

  return ReactRenderer;
}();

var ReactParser = /*#__PURE__*/function () {
  function ReactParser() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults;

    _classCallCheck(this, ReactParser);

    this.options = options;
    this.renderer = options.renderer || new ReactRenderer();
  }

  _createClass(ReactParser, [{
    key: "parse",
    value: function parse(tokens) {
      var _this = this;

      return tokens.map(function (token) {
        switch (token.type) {
          case 'space':
            {
              return null;
            }

          case 'heading':
            {
              return _this.renderer.heading(_this.parseInline(token.tokens), token.depth);
            }

          case 'paragraph':
            {
              return _this.renderer.paragraph(_this.parseInline(token.tokens));
            }

          case 'text':
            {
              return token.tokens ? _this.parseInline(token.tokens) : token.text;
            }

          case 'blockquote':
            {
              var quote = _this.parse(token.tokens);

              return _this.renderer.blockquote(quote);
            }

          case 'list':
            {
              var children = token.items.map(function (item) {
                var listItemChildren = [];

                if (item.task) {
                  listItemChildren.push(_this.renderer.checkbox(item.checked));
                }

                listItemChildren.push(_this.parse(item.tokens));
                return _this.renderer.listItem(listItemChildren);
              });
              return _this.renderer.list(children, token.ordered);
            }

          case 'code':
            {
              return _this.renderer.code(token.text, token.lang);
            }

          case 'html':
            {
              return _this.renderer.html(token.text);
            }

          case 'table':
            {
              var headerCells = token.header.map(function (cell, index) {
                return _this.renderer.tableCell(_this.parseInline(cell.tokens), {
                  header: true,
                  align: token.align[index]
                });
              });

              var headerRow = _this.renderer.tableRow(headerCells);

              var header = _this.renderer.tableHeader(headerRow);

              var bodyChilren = token.rows.map(function (row, index) {
                var rowChildren = row.map(function (cell) {
                  return _this.renderer.tableCell(_this.parseInline(cell.tokens), {
                    header: false,
                    align: token.align[index]
                  });
                });
                return _this.renderer.tableRow(rowChildren);
              });

              var body = _this.renderer.tableBody(bodyChilren);

              return _this.renderer.table([header, body]);
            }

          case 'hr':
            {
              return _this.renderer.hr();
            }

          default:
            {
              console.warn("Token with \"".concat(token.type, "\" type was not found")); // eslint-disable-line no-console

              return null;
            }
        }
      });
    }
  }, {
    key: "parseInline",
    value: function parseInline(tokens) {
      var _this2 = this;

      return tokens.map(function (token) {
        switch (token.type) {
          case 'text':
            {
              return _this2.renderer.text(unescape(token.text));
            }

          case 'strong':
            {
              return _this2.renderer.strong(_this2.parseInline(token.tokens));
            }

          case 'em':
            {
              return _this2.renderer.em(_this2.parseInline(token.tokens));
            }

          case 'del':
            {
              return _this2.renderer.del(_this2.parseInline(token.tokens));
            }

          case 'codespan':
            {
              return _this2.renderer.codespan(unescape(token.text));
            }

          case 'link':
            {
              return _this2.renderer.link(token.href, _this2.parseInline(token.tokens));
            }

          case 'image':
            {
              return _this2.renderer.image(token.href, token.text, token.title);
            }

          case 'html':
            {
              return _this2.renderer.html(token.text);
            }

          case 'br':
            {
              return _this2.renderer.br();
            }

          case 'escape':
            {
              return _this2.renderer.text(token.text);
            }

          default:
            console.warn("Token with \"".concat(token.type, "\" type was not found")); // eslint-disable-line no-console

            return null;
        }
      });
    }
  }]);

  return ReactParser;
}();

var validateComponentProps = function validateComponentProps(props) {
  if (props.value && typeof props.value !== 'string') {
    throw new TypeError("[marked-react]: Expected value to be of type string but got ".concat(_typeof(props.value)));
  }

  if (props.children && typeof props.children !== 'string') {
    throw new TypeError("[marked-react]: Expected children to be of type string but got ".concat(_typeof(props.children)));
  }
};

var Markdown = function Markdown(props) {
  var _ref, _props$value;

  validateComponentProps(props); // lexer options

  var lexerOptions = {
    breaks: props.breaks,
    gfm: props.gfm
  }; // convert input markdown into tokens

  var lexer = new Lexer(lexerOptions);
  var tokens = lexer.lex((_ref = (_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : props.children) !== null && _ref !== void 0 ? _ref : ''); // parser options

  var parserOptions = {
    renderer: new ReactRenderer({
      renderer: props.renderer,
      baseURL: props.baseURL,
      openLinksInNewTab: props.openLinksInNewTab,
      langPrefix: props.langPrefix
    })
  };
  var children = new ReactParser(parserOptions).parse(tokens);
  return /*#__PURE__*/createElement(Fragment, null, children);
};

Markdown.defaultProps = defaults;

export { Markdown as default };
//# sourceMappingURL=marked-react.js.map
